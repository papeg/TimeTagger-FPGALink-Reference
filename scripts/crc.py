# Matrix-based CRC calculation & Verilog output utility
# 
# This file is part of the Time Tagger software defined digital data
# acquisition FPGA-link reference design.
#
# Copyright (C) 2022 Swabian Instruments, All Rights Reserved
#
# Authors:
# - 2022 Leon Schuermann <leon@swabianinstruments.com>
# - 2022 Markus Wick <markus@swabianinstruments.com>
#
# This file is provided under the terms and conditions of the BSD 3-Clause
# license, accessible under https://opensource.org/licenses/BSD-3-Clause.
#
# SPDX-License-Identifier: BSD-3-Clause

import sys
import string
import argparse
import textwrap
import numpy as np
from galois import GF2
from bitarray import bitarray

def intToBitvec(v, width):
    return GF2(np.array([int(i) for i in list(np.binary_repr(v, width=width))]))

def bitvecToInt(bv):
    val = 0
    for i, v in enumerate(np.flip(bv)):
        val |= int(v) << i
    return val

def rightShiftMat(pl):
    # Create a matrix shifiting the input to the right, simulating the
    # CRC LFSR shift register structure.
    rightShiftMat = GF2(np.zeros([pl, pl], dtype=np.uint8))
    rightShiftMat[1:] = np.identity(pl, dtype=np.uint8)[:-1]
    rightShiftMat[0] = np.identity(pl, dtype=np.uint8)[-1]

    return rightShiftMat

def zeroMat(poly):
    # Length of polynom required lots of times throughout this code.
    pl = len(poly)

    # Embed the polynom on the right to perform CRC calculations
    polyMat = rightShiftMat(pl)
    polyMat[:, -1] = np.flip(GF2(poly))

    return polyMat

def bitMat(poly):
    zm = zeroMat(poly)
    (zmr, zmc) = zm.shape
    m = GF2(np.zeros((zmr, zmc + 1), dtype=np.uint8))
    m[:, :-1] = zm
    m[:, -1] = np.flip(GF2(poly))
    return m

def binMat(poly, bits):
    pl = len(poly)
    m = GF2(np.zeros((pl, pl + bits), dtype=np.uint8))
    zm = zeroMat(poly)
    currentH = GF2(np.identity(pl, dtype=np.uint8))
    for i in range(bits):
        m[:, pl + bits - i - 1] = currentH @ np.flip(poly)
        currentH = np.matmul(currentH, zm)
    m[:, :pl] = currentH
    return m

def bitwiseCRC(poly, state, input):
    pl = len(poly)
    stateIn = GF2(np.zeros(pl + len(input), dtype=np.uint8))
    stateIn[:pl] = state
    stateIn[pl:] = input
    #return np.dot(binMat(poly, len(input)), stateIn)
    return np.dot(GF2(H_large), stateIn)

def calculateCRC(poly, initialState, inputs, bitwise=False, finalize=True):
    pl = len(poly)
    state = initialState

    if bitwise:
        bm = bitMat(poly)
        stateIn = GF2(np.zeros(pl + 1, dtype=np.uint8))
        for i in inputs:
            stateIn[:pl] = state
            stateIn[-1] = i
            state = np.dot(bm, stateIn)
    else:
        stateIn = GF2(np.zeros(pl + len(inputs), dtype=np.uint8))
        stateIn[:pl] = state
        stateIn[pl:] = inputs
        state = np.dot(binMat(poly, len(inputs)), stateIn)

    if finalize:
        state = state + GF2(np.array([1 for _ in range(pl)]))

    return state

def verilogCRC(moduleName, crcMat):
    state_bit = crcMat.shape[0]
    input_bit = crcMat.shape[1] - state_bit

    mul_input_assignments = '\n            '.join([
        f"assign mul_input[{idx}] = {src_signal};"
        for idx, src_signal in enumerate(
            list(map(lambda i: f"state_in[{state_bit - i - 1}]", range(state_bit)))
            + list(map(lambda i: f"data_in[{i}]", range(input_bit)))
        )
    ])

    state_out_assignments = '\n'.join([
        '''
            assign state_out[{}] =
                {};
        '''.format(
            state_bit - ridx - 1,
            '\n                ^ '.join([
                f"mul_input[{cidx}]"
                for cidx, val in enumerate(row) if val != 0
            ])
        )
        for ridx, row in enumerate(crcMat)
    ])

    return textwrap.dedent(
        f'''
        // Auto-generated by crc.py
        `timescale 1ns / 1ps
        `default_nettype none


        module {moduleName} (
            input wire [{state_bit}-1:0] state_in,
            input wire [{input_bit}-1:0] data_in,
            output wire [{state_bit}-1:0] state_out
        );

            wire [{state_bit+input_bit}-1:0] mul_input;
            {mul_input_assignments}

            {state_out_assignments}

        endmodule

        `resetall
        '''
    ).strip()

def main():
    def auto_int(x):
        return int(x, 0)

    parser = argparse.ArgumentParser(
        description="Generate combinational unrolled CRC logic in Verilog for arbitrary input sizes.")
    parser.add_argument("--polynom", type=auto_int, default=0x04C11DB7,
                        help="The CRC polynom to use, without leading 1.")
    parser.add_argument("--polynom-width", type=int, default=32,
                        help="Width of polynom and state in bit.")
    parser.add_argument("--initial-state", type=int, default=0xFFFFFFFF,
                        help="Initial state used in the first CRC round.")
    parser.add_argument("--verilog-mod-name", type=str, default="crc",
                        help="When generating Verilog, produce a module with this name.")
    parser.add_argument("--round-bits", type=int, required=True,
                        help="How many bits of input the unrolled CRC processes at a time.")
    parser.add_argument("--input-format", choices=["hex"], default="hex",
                        help=("For the calc command, the format of data passed to stdin."
                              + " 'hex' ignores all non-hex characters."))
    parser.add_argument("command", choices=["gen-verilog", "calc"])
    args = parser.parse_args()

    polyBits = intToBitvec(args.polynom, width=args.polynom_width)
    initState = intToBitvec(args.initial_state, width=args.polynom_width)

    if args.command == "gen-verilog":
        print(verilogCRC(args.verilog_mod_name, binMat(polyBits, args.round_bits)))
    elif args.command == "calc":
        state = initState

        if args.input_format == "hex":
            input_bits = bitarray(endian="little")
            msb_char = None
            for line in sys.stdin:
                for char in line:
                    if char not in string.hexdigits:
                        pass
                    elif msb_char is None:
                        msb_char = char
                    else:
                        input_bits.frombytes(bytearray.fromhex(msb_char + char))
                        msb_char = None

                    if len(input_bits) >= args.round_bits:
                        i = GF2(np.array(input_bits[:args.round_bits].tolist(), dtype=np.uint8))
                        state = calculateCRC(polyBits, state, i, finalize=False)
                        input_bits = input_bits[args.round_bits:]

            state = calculateCRC(polyBits, state, [], finalize=True)
            print(f"{bitvecToInt(state):08x}")
        else:
            raise NotImplementedError()
    else:
        raise NotImplementedError()


if __name__ == "__main__":
    main()
